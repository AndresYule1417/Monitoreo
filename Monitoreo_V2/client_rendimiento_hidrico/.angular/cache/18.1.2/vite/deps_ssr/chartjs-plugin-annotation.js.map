{
  "version": 3,
  "sources": ["../../../../../node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],
  "sourcesContent": ["/*!\r\n* chartjs-plugin-annotation v3.0.1\r\n* https://www.chartjs.org/chartjs-plugin-annotation/index\r\n * (c) 2023 chartjs-plugin-annotation Contributors\r\n * Released under the MIT License\r\n */\nimport { Element, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, defined, isFunction, callback, isObject, valueOrDefault, toRadians, isArray, toFont, addRoundedRectPath, toTRBLCorners, QUARTER_PI, PI, HALF_PI, TWO_THIRDS_PI, TAU, isNumber, RAD_PER_DEG, toPadding, isFinite, toDegrees, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\r\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\n\nconst interaction = {\n  modes: {\n    /**\r\n     * Point mode returns all elements that hit test based on the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\n    point(state, event) {\n      return filterElements(state, event, {\n        intersect: true\n      });\n    },\n    /**\r\n     * Nearest mode returns the element closest to the event position\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\r\n     */\n    nearest(state, event, options) {\n      return getNearestItem(state, event, options);\n    },\n    /**\r\n     * x mode returns the elements that hit-test at the current x coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\n    x(state, event, options) {\n      return filterElements(state, event, {\n        intersect: options.intersect,\n        axis: 'x'\n      });\n    },\n    /**\r\n     * y mode returns the elements that hit-test at the current y coordinate\r\n     * @param {Object} state - the state of the plugin\r\n     * @param {ChartEvent} event - the event we are find things at\r\n     * @param {Object} options - interaction options to use\r\n     * @return {AnnotationElement[]} - elements that are found\r\n     */\n    y(state, event, options) {\n      return filterElements(state, event, {\n        intersect: options.intersect,\n        axis: 'y'\n      });\n    }\n  }\n};\n\n/**\r\n * Returns all elements that hit test based on the event position\r\n * @param {Object} state - the state of the plugin\r\n * @param {ChartEvent} event - the event we are find things at\r\n * @param {Object} options - interaction options to use\r\n * @return {AnnotationElement[]} - elements that are found\r\n */\nfunction getElements(state, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(state, event, options);\n}\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {\n      x: event.x,\n      y: center.y\n    };\n  } else if (axis === 'y') {\n    return {\n      x: center.x,\n      y: event.y\n    };\n  }\n  return center;\n}\nfunction filterElements(state, event, options) {\n  return state.visibleElements.filter(element => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\nfunction getNearestItem(state, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return filterElements(state, event, options).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const evenPoint = getPointByAxis(event, center, options.axis);\n    const distance = distanceBetweenPoints(event, evenPoint);\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1); // return only the top item;\n}\nconst isOlderPart = (act, req) => req > act || act.length > req.length && act.slice(0, req.length) === req;\n\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\r\n * @param {Object} obj\r\n * @param {number} from\r\n * @param {number} to\r\n * @returns {Object}\r\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\r\n * @param {Point} point\r\n * @param {Point} center\r\n * @param {number} radius\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\nfunction inPointRange(point, center, radius, borderWidth) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  const hBorderWidth = borderWidth / 2;\n  return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hBorderWidth, 2);\n}\n\n/**\r\n * @param {Point} point\r\n * @param {{x: number, y: number, x2: number, y2: number}} rect\r\n * @param {InteractionAxis} axis\r\n * @param {number} borderWidth\r\n * @returns {boolean}\r\n */\nfunction inBoxRange(point, {\n  x,\n  y,\n  x2,\n  y2\n}, axis, borderWidth) {\n  const hBorderWidth = borderWidth / 2;\n  const inRangeX = point.x >= x - hBorderWidth - EPSILON && point.x <= x2 + hBorderWidth + EPSILON;\n  const inRangeY = point.y >= y - hBorderWidth - EPSILON && point.y <= y2 + hBorderWidth + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\r\n * @param {AnnotationElement} element\r\n * @param {boolean} useFinalPosition\r\n * @returns {Point}\r\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {\n    centerX,\n    centerY\n  } = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {\n    x: centerX,\n    y: centerY\n  };\n}\n\n/**\r\n * @param {string} pkg\r\n * @param {string} min\r\n * @param {string} ver\r\n * @param {boolean} [strict=true]\r\n * @returns {boolean}\r\n */\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nconst isPercentString = s => typeof s === 'string' && s.endsWith('%');\nconst toPercent = s => parseFloat(s) / 100;\nconst toPositivePercent = s => clamp(toPercent(s), 0, 1);\nconst boxAppering = (x, y) => ({\n  x,\n  y,\n  x2: x,\n  y2: y,\n  width: 0,\n  height: 0\n});\nconst defaultInitAnimation = {\n  box: properties => boxAppering(properties.centerX, properties.centerY),\n  ellipse: properties => ({\n    centerX: properties.centerX,\n    centerY: properties.centerX,\n    radius: 0,\n    width: 0,\n    height: 0\n  }),\n  label: properties => boxAppering(properties.centerX, properties.centerY),\n  line: properties => boxAppering(properties.x, properties.y),\n  point: properties => ({\n    centerX: properties.centerX,\n    centerY: properties.centerY,\n    radius: 0,\n    width: 0,\n    height: 0\n  }),\n  polygon: properties => boxAppering(properties.centerX, properties.centerY)\n};\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\r\n */\n\n/**\r\n * @param {number} size\r\n * @param {number|string} position\r\n * @returns {number}\r\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPositivePercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\r\n * @param {number} size\r\n * @param {number|string} value\r\n * @param {boolean} [positivePercent=true]\r\n * @returns {number}\r\n */\nfunction getSize(size, value, positivePercent = true) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return (positivePercent ? toPositivePercent(value) : toPercent(value)) * size;\n  }\n  return size;\n}\n\n/**\r\n * @param {{x: number, width: number}} size\r\n * @param {CoreLabelOptions} options\r\n * @returns {number}\r\n */\nfunction calculateTextAlignment(size, options) {\n  const {\n    x,\n    width\n  } = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\r\n * @param {{x: number|string, y: number|string}|string|number} value\r\n * @param {string|number} defaultValue\r\n * @returns {{x: number|string, y: number|string}}\r\n */\nfunction toPosition(value, defaultValue = 'center') {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, defaultValue),\n      y: valueOrDefault(value.y, defaultValue)\n    };\n  }\n  value = valueOrDefault(value, defaultValue);\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\r\n * @param {AnnotationPointCoordinates} options\r\n * @returns {boolean}\r\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {AnnotationBoxModel} properties\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {AnnotationElement}\r\n */\nfunction initAnimationProperties(chart, properties, options) {\n  const initAnim = options.init;\n  if (!initAnim) {\n    return;\n  } else if (initAnim === true) {\n    return applyDefault(properties, options);\n  }\n  return execCallback(chart, properties, options);\n}\n\n/**\r\n * @param {Object} options\r\n * @param {Array} hooks\r\n * @param {Object} hooksContainer\r\n * @returns {boolean}\r\n */\nfunction loadHooks(options, hooks, hooksContainer) {\n  let activated = false;\n  hooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      activated = true;\n      hooksContainer[hook] = options[hook];\n    } else if (defined(hooksContainer[hook])) {\n      delete hooksContainer[hook];\n    }\n  });\n  return activated;\n}\nfunction applyDefault(properties, options) {\n  const type = options.type || 'line';\n  return defaultInitAnimation[type](properties);\n}\nfunction execCallback(chart, properties, options) {\n  const result = callback(options.init, [{\n    chart,\n    properties,\n    options\n  }]);\n  if (result === true) {\n    return applyDefault(properties, options);\n  } else if (isObject(result)) {\n    return result;\n  }\n}\nconst widthCache = new Map();\nconst notRadius = radius => isNaN(radius) || radius <= 0;\nconst fontsKey = fonts => fonts.reduce(function (prev, item) {\n  prev += item.string;\n  return prev;\n}, '');\n\n/**\r\n * @typedef { import('chart.js').Point } Point\r\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n */\n\n/**\r\n * Determine if content is an image or a canvas.\r\n * @param {*} content\r\n * @returns boolean|undefined\r\n * @todo move this function to chart.js helpers\r\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]';\n  }\n}\n\n/**\r\n * Set the translation on the canvas if the rotation must be applied.\r\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\r\n * @param {Point} point - the point of translation\r\n * @param {number} rotation - rotation (in degrees) to apply\r\n */\nfunction translate(ctx, {\n  x,\n  y\n}, rotation) {\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n * @returns {boolean|undefined}\r\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {Object} options\r\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {CoreLabelOptions} options\r\n * @returns {{width: number, height: number}}\r\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    return {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n  }\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + fontsKey(fonts) + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    widthCache.set(mapKey, calculateLabelSize(ctx, lines, fonts, strokeWidth));\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {Object} options\r\n */\nfunction drawBox(ctx, rect, options) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x,\n    y,\n    w: width,\n    h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{x: number, y: number, width: number, height: number}} rect\r\n * @param {CoreLabelOptions} options\r\n */\nfunction drawLabel(ctx, rect, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.save();\n    ctx.globalAlpha = getOpacity(options.opacity, content.style.opacity);\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    ctx.restore();\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const optFont = options.font;\n  const fonts = isArray(optFont) ? optFont.map(f => toFont(f)) : [toFont(optFont)];\n  const optColor = options.color;\n  const colors = isArray(optColor) ? optColor : [optColor];\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    applyLabelDecoration(ctx, {\n      x,\n      y\n    }, labels, fonts);\n  }\n  applyLabelContent(ctx, {\n    x,\n    y\n  }, labels, {\n    fonts,\n    colors\n  });\n  ctx.restore();\n}\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\r\n * @param {CanvasRenderingContext2D} ctx\r\n * @param {{radius: number, options: PointAnnotationOptions}} element\r\n * @param {number} x\r\n * @param {number} y\r\n */\nfunction drawPoint(ctx, element, x, y) {\n  const {\n    radius,\n    options\n  } = element;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (isImageOrCanvas(style)) {\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(rad);\n    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n    ctx.restore();\n    return;\n  }\n  if (notRadius(radius)) {\n    return;\n  }\n  drawPointStyle(ctx, {\n    x,\n    y,\n    radius,\n    rotation,\n    style,\n    rad\n  });\n}\nfunction drawPointStyle(ctx, {\n  x,\n  y,\n  radius,\n  rotation,\n  style,\n  rad\n}) {\n  let xOffset, yOffset, size, cornerRadius;\n  ctx.beginPath();\n  switch (style) {\n    // Default includes circle\n    default:\n      ctx.arc(x, y, radius, 0, TAU);\n      ctx.closePath();\n      break;\n    case 'triangle':\n      ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n      // NOTE: the rounded rect implementation changed to use `arc` instead of\n      // `quadraticCurveTo` since it generates better results when rect is\n      // almost a circle. 0.516 (instead of 0.5) produces results with visually\n      // closer proportion to the previous impl and it is inscribed in the\n      // circle with `radius`. For more details, see the following PRs:\n      // https://github.com/chartjs/Chart.js/issues/5597\n      // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        ctx.rect(x - size, y - size, 2 * size, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n    case 'star':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      rad += QUARTER_PI;\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      ctx.moveTo(x + yOffset, y - xOffset);\n      ctx.lineTo(x - yOffset, y + xOffset);\n      break;\n    case 'line':\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n      break;\n  }\n  ctx.fill();\n}\nfunction calculateLabelSize(ctx, lines, fonts, strokeWidth) {\n  ctx.save();\n  const count = lines.length;\n  let width = 0;\n  let height = strokeWidth;\n  for (let i = 0; i < count; i++) {\n    const font = fonts[Math.min(i, fonts.length - 1)];\n    ctx.font = font.string;\n    const text = lines[i];\n    width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    height += font.lineHeight;\n  }\n  ctx.restore();\n  return {\n    width,\n    height\n  };\n}\nfunction applyLabelDecoration(ctx, {\n  x,\n  y\n}, labels, fonts) {\n  ctx.beginPath();\n  let lhs = 0;\n  labels.forEach(function (l, i) {\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.font = f.string;\n    ctx.strokeText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n  });\n  ctx.stroke();\n}\nfunction applyLabelContent(ctx, {\n  x,\n  y\n}, labels, {\n  fonts,\n  colors\n}) {\n  let lhs = 0;\n  labels.forEach(function (l, i) {\n    const c = colors[Math.min(i, colors.length - 1)];\n    const f = fonts[Math.min(i, fonts.length - 1)];\n    const lh = f.lineHeight;\n    ctx.beginPath();\n    ctx.font = f.string;\n    ctx.fillStyle = c;\n    ctx.fillText(l, x, y + lh / 2 + lhs);\n    lhs += lh;\n    ctx.fill();\n  });\n}\nfunction getOpacity(value, elementValue) {\n  const opacity = isNumber(value) ? value : elementValue;\n  return isNumber(opacity) ? clamp(opacity, 0, 1) : 1;\n}\nconst limitedLineScale = {\n  xScaleID: {\n    min: 'xMin',\n    max: 'xMax',\n    start: 'left',\n    end: 'right',\n    startProp: 'x',\n    endProp: 'x2'\n  },\n  yScaleID: {\n    min: 'yMin',\n    max: 'yMax',\n    start: 'bottom',\n    end: 'top',\n    startProp: 'y',\n    endProp: 'y2'\n  }\n};\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import(\"chart.js\").Point } Point\r\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n * @typedef { import('../../types/options').LineAnnotationOptions } LineAnnotationOptions\r\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\r\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\r\n */\n\n/**\r\n * @param {Scale} scale\r\n * @param {number|string} value\r\n * @param {number} fallback\r\n * @returns {number}\r\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\r\n * Search the scale defined in chartjs by the axis related to the annotation options key.\r\n * @param {{ [key: string]: Scale }} scales\r\n * @param {CoreAnnotationOptions} options\r\n * @param {string} key\r\n * @returns {string}\r\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter(scale => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\r\n * @param {Scale} scale\r\n * @param {{min: number, max: number, start: number, end: number}} options\r\n * @returns {{start: number, end: number}|undefined}\r\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {Point}\r\n */\nfunction getChartPoint(chart, options) {\n  const {\n    chartArea,\n    scales\n  } = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {\n    x,\n    y\n  };\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  if (!xScale && !yScale) {\n    return {};\n  }\n  let {\n    left: x,\n    right: x2\n  } = xScale || chart.chartArea;\n  let {\n    top: y,\n    bottom: y2\n  } = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {\n    min: options.xMin,\n    max: options.xMax,\n    start: x,\n    end: x2\n  });\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {\n    min: options.yMin,\n    max: options.yMax,\n    start: y2,\n    end: y\n  });\n  y = yDim.start;\n  y2 = yDim.end;\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    const adjustCenterX = box.centerX + options.xAdjust;\n    const adjustCenterY = box.centerY + options.yAdjust;\n    return {\n      x: adjustCenterX - radius,\n      y: adjustCenterY - radius,\n      x2: adjustCenterX + radius,\n      y2: adjustCenterY + radius,\n      centerX: adjustCenterX,\n      centerY: adjustCenterY,\n      width: size,\n      height: size,\n      radius\n    };\n  }\n  return getChartCircle(chart, options);\n}\n/**\r\n * @param {Chart} chart\r\n * @param {LineAnnotationOptions} options\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolveLineProperties(chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const scale = scales[options.scaleID];\n  const area = {\n    x: chartArea.left,\n    y: chartArea.top,\n    x2: chartArea.right,\n    y2: chartArea.bottom\n  };\n  if (scale) {\n    resolveFullLineProperties(scale, area, options);\n  } else {\n    resolveLimitedLineProperties(scales, area, options);\n  }\n  return area;\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {CoreAnnotationOptions} options\r\n * @param {boolean} [centerBased=false]\r\n * @returns {AnnotationBoxModel}\r\n */\nfunction resolveBoxAndLabelProperties(chart, options) {\n  const properties = resolveBoxProperties(chart, options);\n  properties.initProperties = initAnimationProperties(chart, properties, options);\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options),\n    initProperties: properties.initProperties\n  }];\n  return properties;\n}\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    radius: options.radius,\n    width: size,\n    height: size\n  };\n}\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\nfunction resolveFullLineProperties(scale, area, options) {\n  const min = scaleValue(scale, options.value, NaN);\n  const max = scaleValue(scale, options.endValue, min);\n  if (scale.isHorizontal()) {\n    area.x = min;\n    area.x2 = max;\n  } else {\n    area.y = min;\n    area.y2 = max;\n  }\n}\nfunction resolveLimitedLineProperties(scales, area, options) {\n  for (const scaleId of Object.keys(limitedLineScale)) {\n    const scale = scales[retrieveScaleID(scales, options, scaleId)];\n    if (scale) {\n      const {\n        min,\n        max,\n        start,\n        end,\n        startProp,\n        endProp\n      } = limitedLineScale[scaleId];\n      const dim = getDimensionByScale(scale, {\n        min: options[min],\n        max: options[max],\n        start: scale[start],\n        end: scale[end]\n      });\n      area[startProp] = dim.start;\n      area[endProp] = dim.end;\n    }\n  }\n}\nfunction calculateX({\n  properties,\n  options\n}, labelSize, position, padding) {\n  const {\n    x: start,\n    x2: end,\n    width: size\n  } = properties;\n  return calculatePosition$1({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.x,\n    padding: {\n      start: padding.left,\n      end: padding.right\n    },\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\nfunction calculateY({\n  properties,\n  options\n}, labelSize, position, padding) {\n  const {\n    y: start,\n    y2: end,\n    height: size\n  } = properties;\n  return calculatePosition$1({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.y,\n    padding: {\n      start: padding.top,\n      end: padding.bottom\n    },\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\nfunction calculatePosition$1(boxOpts, labelOpts) {\n  const {\n    start,\n    end,\n    borderWidth\n  } = boxOpts;\n  const {\n    position,\n    padding: {\n      start: padStart,\n      end: padEnd\n    },\n    adjust\n  } = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const y = calculateY({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n}\n\n/**\r\n * @typedef {import('chart.js').Point} Point\r\n */\n\n/**\r\n * Rotate a `point` relative to `center` point by `angle`\r\n * @param {Point} point - the point to rotate\r\n * @param {Point} center - center point for rotation\r\n * @param {number} angle - angle for rotation, in radians\r\n * @returns {Point} rotated point\r\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\nconst moveHooks = ['enter', 'leave'];\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\n\nconst eventHooks = moveHooks.concat('click');\n\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = loadHooks(options, eventHooks, state.listeners);\n  state.moveListened = false;\n  state._getElements = getElements; // for testing\n\n  moveHooks.forEach(hook => {\n    if (isFunction(options[hook])) {\n      state.moveListened = true;\n    }\n  });\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && isFunction(scope.click)) {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (isFunction(scope[hook])) {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\r\n * @param {Object} state\r\n * @param {ChartEvent} event\r\n * @param {AnnotationPluginOptions} options\r\n * @return {boolean|undefined}\r\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        return handleMoveEvents(state, event, options);\n      case 'click':\n        return handleClickEvents(state, event, options);\n    }\n  }\n}\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n  let elements;\n  if (event.type === 'mousemove') {\n    elements = getElements(state, event, options.interaction);\n  } else {\n    elements = [];\n  }\n  const previous = state.hovered;\n  state.hovered = elements;\n  const context = {\n    state,\n    event\n  };\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\nfunction dispatchMoveEvents({\n  state,\n  event\n}, hook, elements, checkElements) {\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\r\n */\n\nconst elementHooks = ['afterDraw', 'beforeDraw'];\n\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n */\nfunction updateHooks(chart, state, options) {\n  const visibleElements = state.visibleElements;\n  state.hooked = loadHooks(options, elementHooks, state.hooks);\n  if (!state.hooked) {\n    visibleElements.forEach(scope => {\n      if (!state.hooked) {\n        elementHooks.forEach(hook => {\n          if (isFunction(scope.options[hook])) {\n            state.hooked = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\r\n * @param {Object} state\r\n * @param {AnnotationElement} element\r\n * @param {string} hook\r\n */\nfunction invokeHook(state, element, hook) {\n  if (state.hooked) {\n    const callbackHook = element.options[hook] || state.hooks[hook];\n    return callback(callbackHook, [element.$context]);\n  }\n}\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").Scale } Scale\r\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\r\n */\n\n/**\r\n * @param {Chart} chart\r\n * @param {Scale} scale\r\n * @param {CoreAnnotationOptions[]} annotations\r\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && isFunction(scale.handleTickRangeOptions)) {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\r\n * @param {CoreAnnotationOptions[]} annotations\r\n * @param {{ [key: string]: Scale }} scales\r\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n    }\n  }\n}\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({\n      x,\n      y\n    }, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nconst positions = ['left', 'bottom', 'top', 'right'];\nclass LabelAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.rotation));\n    return inBoxRange({\n      x,\n      y\n    }, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {\n        centerX,\n        centerY\n      } = resolveBoxProperties(chart, options);\n      point = {\n        x: centerX,\n        y: centerY\n      };\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureRect(point, labelSize, options, padding);\n    return {\n      initProperties: initAnimationProperties(chart, boxSize, options),\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      rotation: options.rotation\n    };\n  }\n}\nLabelAnnotation.id = 'labelAnnotation';\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%'\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  init: undefined,\n  opacity: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction measureRect(point, size, options, padding) {\n  const width = size.width + padding.width + options.borderWidth;\n  const height = size.height + padding.height + options.borderWidth;\n  const position = toPosition(options.position, 'center');\n  const x = calculatePosition(point.x, width, options.xAdjust, position.x);\n  const y = calculatePosition(point.y, height, options.yAdjust, position.y);\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\nfunction calculatePosition(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\nfunction drawCallout(ctx, element) {\n  const {\n    pointX,\n    pointY,\n    options\n  } = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {\n    separatorStart,\n    separatorEnd\n  } = getCalloutSeparatorCoord(element, calloutPosition);\n  const {\n    sideStart,\n    sideEnd\n  } = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({\n    x: pointX,\n    y: pointY\n  }, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction getCalloutSeparatorCoord(element, position) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {\n      x: x + adjust,\n      y\n    };\n    separatorEnd = {\n      x: separatorStart.x,\n      y: y2\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {\n      x,\n      y: y + adjust\n    };\n    separatorEnd = {\n      x: x2,\n      y: separatorStart.y\n    };\n  }\n  return {\n    separatorStart,\n    separatorEnd\n  };\n}\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {\n    width,\n    height,\n    options\n  } = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {\n    y,\n    width,\n    height,\n    options\n  } = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {\n      x: separatorStart.x,\n      y: y + getSize(height, start)\n    };\n    sideEnd = {\n      x: sideStart.x + side,\n      y: sideStart.y\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {\n      x: separatorStart.x + getSize(width, start),\n      y: separatorStart.y\n    };\n    sideEnd = {\n      x: sideStart.x,\n      y: sideStart.y + side\n    };\n  }\n  return {\n    sideStart,\n    sideEnd\n  };\n}\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\nfunction resolveCalloutAutoPosition(element, options) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    width,\n    height,\n    pointX,\n    pointY,\n    centerX,\n    centerY,\n    rotation\n  } = element;\n  const center = {\n    x: centerX,\n    y: centerY\n  };\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({\n      x: xPoints[index],\n      y: yPoints[index]\n    }, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {\n        x: pointX,\n        y: pointY\n      })\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\nfunction getLabelSize({\n  x,\n  y,\n  width,\n  height,\n  options\n}) {\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\nfunction isPointInRange(element, callout, position) {\n  const {\n    pointX,\n    pointY\n  } = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, {\n  x,\n  y,\n  x2,\n  y2\n}, axis) => axis === 'y' ? {\n  start: Math.min(y, y2),\n  end: Math.max(y, y2),\n  value: mouseY\n} : {\n  start: Math.min(x, x2),\n  end: Math.max(x, x2),\n  value: mouseX\n};\n// http://www.independent-software.com/determining-coordinates-on-a-html-canvas-bezier-curve.html\nconst coordInCurve = (start, cp, end, t) => (1 - t) * (1 - t) * start + 2 * (1 - t) * t * cp + t * t * end;\nconst pointInCurve = (start, cp, end, t) => ({\n  x: coordInCurve(start.x, cp.x, end.x, t),\n  y: coordInCurve(start.y, cp.y, end.y, t)\n});\nconst coordAngleInCurve = (start, cp, end, t) => 2 * (1 - t) * (cp - start) + 2 * t * (end - cp);\nconst angleInCurve = (start, cp, end, t) => -Math.atan2(coordAngleInCurve(start.x, cp.x, end.x, t), coordAngleInCurve(start.y, cp.y, end.y, t)) + 0.5 * PI;\nclass LineAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hBorderWidth = this.options.borderWidth / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const point = {\n        mouseX,\n        mouseY\n      };\n      const {\n        path,\n        ctx\n      } = this;\n      if (path) {\n        setBorderStyle(ctx, this.options);\n        const {\n          chart\n        } = this.$context;\n        const mx = mouseX * chart.currentDevicePixelRatio;\n        const my = mouseY * chart.currentDevicePixelRatio;\n        const result = ctx.isPointInStroke(path, mx, my) || isOnLabel(this, point, useFinalPosition);\n        ctx.restore();\n        return result;\n      }\n      const epsilon = sqr(hBorderWidth);\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    return inAxisRange(this, {\n      mouseX,\n      mouseY\n    }, axis, {\n      hBorderWidth,\n      useFinalPosition\n    });\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      cp,\n      options\n    } = this;\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    if (options.curve && cp) {\n      drawCurve(ctx, this, cp, length);\n      return ctx.restore();\n    }\n    const {\n      startOpts,\n      endOpts,\n      startAdjust,\n      endAdjust\n    } = getArrowHeads(this);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    const area = resolveLineProperties(chart, options);\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside ? limitLineToArea({\n      x,\n      y\n    }, {\n      x: x2,\n      y: y2\n    }, chart.chartArea) : {\n      x,\n      y,\n      x2,\n      y2,\n      width: Math.abs(x2 - x),\n      height: Math.abs(y2 - y)\n    };\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    if (options.curve) {\n      const p1 = {\n        x: properties.x,\n        y: properties.y\n      };\n      const p2 = {\n        x: properties.x2,\n        y: properties.y2\n      };\n      properties.cp = getControlPoint(properties, options, distanceBetweenPoints(p1, p2));\n    }\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties,\n      initProperties: properties.initProperties\n    }];\n    return properties;\n  }\n}\nLineAnnotation.id = 'lineAnnotation';\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  curve: false,\n  controlPoint: {\n    y: '-50%'\n  },\n  display: true,\n  endValue: undefined,\n  init: undefined,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    opacity: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction inAxisRange(element, {\n  mouseX,\n  mouseY\n}, axis, {\n  hBorderWidth,\n  useFinalPosition\n}) {\n  const limit = rangeLimit(mouseX, mouseY, element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n  return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth || isOnLabel(element, {\n    mouseX,\n    mouseY\n  }, useFinalPosition, axis);\n}\nfunction isLineInArea({\n  x,\n  y,\n  x2,\n  y2\n}, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\nfunction limitPointToArea({\n  x,\n  y\n}, p2, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  if (x < left) {\n    y = interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\nfunction intersects(element, {\n  mouseX,\n  mouseY\n}, epsilon = EPSILON, useFinalPosition) {\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {\n    x: x1,\n    y: y1,\n    x2,\n    y2\n  } = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return sqr(mouseX - xx) + sqr(mouseY - yy) <= epsilon;\n}\nfunction isOnLabel(element, {\n  mouseX,\n  mouseY\n}, useFinalPosition, axis) {\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {\n    width,\n    height,\n    padding\n  }, chart.chartArea);\n}\nfunction calculateAutoRotation(properties) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {\n    width,\n    height,\n    padding\n  } = sizes;\n  const {\n    xAdjust,\n    yAdjust\n  } = label;\n  const p1 = {\n    x: properties.x,\n    y: properties.y\n  };\n  const p2 = {\n    x: properties.x2,\n    y: properties.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {\n    labelSize: size,\n    padding\n  }, chartArea);\n  const pt = properties.cp ? pointInCurve(p1, properties.cp, p2, t) : pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: padding.left\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: padding.top\n  };\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - width / 2,\n    y: centerY - height / 2,\n    x2: centerX + width / 2,\n    y2: centerY + height / 2,\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({\n      w: properties.x2 - properties.x,\n      h: properties.y2 - properties.y\n    }, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: properties.x - properties.x2,\n      h: properties.y - properties.y2\n    }, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {\n    labelSize,\n    padding\n  } = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\nfunction spaceAround(properties, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {\n    length,\n    width\n  } = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {\n    x: length,\n    y: width + adjust\n  };\n  const p2 = {\n    x: 0,\n    y: adjust\n  };\n  return Math.abs(interpolateX(0, p1, p2));\n}\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {\n    length,\n    width,\n    fill,\n    backgroundColor,\n    borderColor\n  } = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\nfunction getControlPoint(properties, options, distance) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    centerX,\n    centerY\n  } = properties;\n  const angle = Math.atan2(y2 - y, x2 - x);\n  const cp = toPosition(options.controlPoint, 0);\n  const point = {\n    x: centerX + getSize(distance, cp.x, false),\n    y: centerY + getSize(distance, cp.y, false)\n  };\n  return rotated(point, {\n    x: centerX,\n    y: centerY\n  }, angle);\n}\nfunction drawArrowHeadOnCurve(ctx, {\n  x,\n  y\n}, {\n  angle,\n  adjust\n}, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.rotate(angle);\n  drawArrowHead(ctx, 0, -adjust, arrowOpts);\n  ctx.restore();\n}\nfunction drawCurve(ctx, element, cp, length) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    options\n  } = element;\n  const {\n    startOpts,\n    endOpts,\n    startAdjust,\n    endAdjust\n  } = getArrowHeads(element);\n  const p1 = {\n    x,\n    y\n  };\n  const p2 = {\n    x: x2,\n    y: y2\n  };\n  const startAngle = angleInCurve(p1, cp, p2, 0);\n  const endAngle = angleInCurve(p1, cp, p2, 1) - PI;\n  const ps = pointInCurve(p1, cp, p2, startAdjust / length);\n  const pe = pointInCurve(p1, cp, p2, 1 - endAdjust / length);\n  const path = new Path2D();\n  ctx.beginPath();\n  path.moveTo(ps.x, ps.y);\n  path.quadraticCurveTo(cp.x, cp.y, pe.x, pe.y);\n  ctx.shadowColor = options.borderShadowColor;\n  ctx.stroke(path);\n  element.path = path;\n  element.ctx = ctx;\n  drawArrowHeadOnCurve(ctx, ps, {\n    angle: startAngle,\n    adjust: startAdjust\n  }, startOpts);\n  drawArrowHeadOnCurve(ctx, pe, {\n    angle: endAngle,\n    adjust: endAdjust\n  }, endOpts);\n}\nclass EllipseAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({\n        x: mouseX,\n        y: mouseY\n      }, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, borderWidth);\n    }\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2\n    } : {\n      start: x,\n      end: x2\n    };\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON && rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      width,\n      height,\n      centerX,\n      centerY,\n      options\n    } = this;\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\n  const {\n    width,\n    height,\n    centerX,\n    centerY\n  } = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const hBorderWidth = borderWidth / 2 || 0;\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return a / Math.pow(xRadius + hBorderWidth, 2) + b / Math.pow(yRadius + hBorderWidth, 2) <= 1.0001;\n}\nclass PointAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      width\n    } = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({\n        x: mouseX,\n        y: mouseY\n      }, this.getCenterPoint(useFinalPosition), width / 2, borderWidth);\n    }\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2,\n      value: mouseY\n    } : {\n      start: x,\n      end: x2,\n      value: mouseX\n    };\n    return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    drawPoint(ctx, this, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    properties.initProperties = initAnimationProperties(chart, properties, options);\n    return properties;\n  }\n}\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nclass PolygonAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map(point => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      elements,\n      options\n    } = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {\n      sides,\n      rotation\n    } = options;\n    const elements = [];\n    const angle = 2 * PI / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      const elProps = buildPointElement(properties, options, rad);\n      elProps.initProperties = initAnimationProperties(chart, properties, options);\n      elements.push(elProps);\n    }\n    properties.elements = elements;\n    return properties;\n  }\n}\nPolygonAnnotation.id = 'polygonAnnotation';\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  init: undefined,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nfunction buildPointElement({\n  centerX,\n  centerY\n}, {\n  radius,\n  borderWidth\n}, rad) {\n  const halfBorder = borderWidth / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {\n    x: centerX + sin * radius,\n    y: centerY - cos * radius\n  };\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + halfBorder),\n      bY: centerY - cos * (radius + halfBorder)\n    }\n  };\n}\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\nconst annotationTypes = {\n  box: BoxAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\r\n * Register fallback for annotation elements\r\n * For example lineAnnotation options would be looked through:\r\n * - the annotation object (options.plugins.annotation.annotations[id])\r\n * - element options (options.elements.lineAnnotation)\r\n * - element defaults (defaults.elements.lineAnnotation)\r\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\r\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation.common'\n  });\n});\nconst directUpdater = {\n  update: Object.assign\n};\nconst hooks$1 = eventHooks.concat(elementHooks);\nconst resolve = (value, optDefs) => isObject(optDefs) ? resolveObj(value, optDefs) : value;\n\n/**\r\n * @typedef { import(\"chart.js\").Chart } Chart\r\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\r\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\r\n */\n\n/**\r\n * @param {string} prop\r\n * @returns {boolean}\r\n */\nconst isIndexable = prop => prop === 'color' || prop === 'font';\n\n/**\r\n * Resolve the annotation type, checking if is supported.\r\n * @param {string} [type=line] - annotation type\r\n * @returns {string} resolved annotation type\r\n */\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n\n/**\r\n * @param {Chart} chart\r\n * @param {Object} state\r\n * @param {AnnotationPluginOptions} options\r\n * @param {UpdateMode} mode\r\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n    properties.skip = toSkip(properties);\n    if ('elements' in properties) {\n      updateSubElements(element, properties.elements, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n    Object.assign(element, properties.initProperties);\n    properties.options = resolveAnnotationOptions(resolver);\n    animations.update(element, properties);\n  }\n}\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\nfunction updateSubElements(mainElement, elements, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, definition.initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    Object.assign(element, initProperties);\n  }\n  return element;\n}\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elementClass.defaults), resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks$1) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    if (isIndexable(prop) && isArray(value)) {\n      result[prop] = value.map(item => resolve(item, optDefs));\n    } else {\n      result[prop] = resolve(value, optDefs);\n    }\n  }\n  return result;\n}\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\nvar version = \"3.0.1\";\nconst chartStates = new Map();\nconst hooks = eventHooks.concat(elementHooks);\nvar annotation = {\n  id: 'annotation',\n  version,\n  beforeRegister() {\n    requireVersion('chart.js', '4.0', Chart.version);\n  },\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hooks: {},\n      hooked: false,\n      hovered: []\n    });\n  },\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations, chart.scales);\n  },\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n    updateHooks(chart, state, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      }\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      init: false,\n      label: {}\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop) && prop !== 'init',\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _indexable: isIndexable,\n        _fallback: true\n      },\n      _indexable: isIndexable\n    }\n  },\n  additionalOptionScopes: ['']\n};\nfunction draw(chart, caller, clip) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const state = chartStates.get(chart);\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n  const drawableElements = getDrawableElements(state.visibleElements, caller).sort((a, b) => a.element.options.z - b.element.options.z);\n  for (const item of drawableElements) {\n    drawElement(ctx, chartArea, state, item);\n  }\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push({\n        element: el,\n        main: true\n      });\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push({\n            element: sub\n          });\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\nfunction drawElement(ctx, chartArea, state, item) {\n  const el = item.element;\n  if (item.main) {\n    invokeHook(state, el, 'beforeDraw');\n    el.draw(ctx, chartArea);\n    invokeHook(state, el, 'afterDraw');\n  } else {\n    el.draw(ctx, chartArea);\n  }\n}\nexport { annotation as default };"],
  "mappings": "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",
  "names": ["getRelativePosition", "hooks", "drawPoint", "annotation", "resolve"]
}
